import { Collection } from 'mongodb'

interface Document {
  [others: string]: any
}

export interface VersionedDocument extends Document {
  _id: string
  _v: number
}

interface SingleDocumentUpdater {
  update(document: Document): Document | Promise<Document>
}

interface DocumentBatchUpdater {
  updateMany(documents: Document[]): Document[] | Promise<Document[]>
}

export type SchemaRevision = SingleDocumentUpdater | DocumentBatchUpdater

type SchemaEnforcer = {
  (instance: VersionedDocument, persist?: boolean): Promise<VersionedDocument>
  (instances: VersionedDocument[], persist?: boolean): Promise<VersionedDocument[]>
}

type PlainOrArray<T> = T | T[]

const createSchema = (revisions: SchemaRevision[], collection: Collection) : SchemaEnforcer => {
  const schemaVersion = revisions.length

  const updateDocuments: SchemaEnforcer = async (input: PlainOrArray<VersionedDocument>, persist: boolean = true): Promise<any> => {
    let singleDocument = false
    if (!Array.isArray(input)) {
      singleDocument = true
      input = [ input ]
    }

    const documentsByVersion = {}
    const documentIndexById = {}
    for (const i in input) {
      const document = input[i]
      const version = document._v

      documentIndexById[document._id] = i

      if (!(version in documentsByVersion)) {
        documentsByVersion[version] = []
      }
      documentsByVersion[version].push(document)
    }

    const getIndex = (document: { _id: string }) => document
      ? documentIndexById[document._id]
      : -1

    // @ts-ignore
    for (let version = Math.min(...Object.keys(documentsByVersion)); version < schemaVersion; version++) {
      const revision: SchemaRevision = revisions[version]
      let documents = documentsByVersion[version]

      if ('updateMany' in revision) {
        documents = await revision.updateMany(documents)
      } else {
        documents = await Promise.all(documents.map((document: object) => revision.update(document)))
      }

      if (version === schemaVersion - 1) {
        documents.forEach((document) => {
          if (document._v !== schemaVersion) {
            document._v = schemaVersion // assignment is safe because (_v !== schemaVersion) implies that the document was generated by an update function
          }
        })

        if (persist) {
          await collection.bulkWrite(documents.map((document) => ({
            replaceOne: {
              filter: { _id: document._id },
              replacement: document
            }
          })))
        }
      }

      const nextVersionDocuments = documentsByVersion[version + 1] || []
      const result = documentsByVersion[version + 1] = []
      const documentCount = documents.length + nextVersionDocuments.length

      let nVIndex = getIndex(nextVersionDocuments[0]),
        cDIndex = getIndex(documents[0])
      for (let i = 0; i < documentCount; i++) {
        if (cDIndex === -1) {
          result.push(...nextVersionDocuments)
          break
        } else if (nVIndex === -1) {
          result.push(...documents)
          break
        }

        if (nVIndex < cDIndex) {
          result.push(nextVersionDocuments.shift())
          nVIndex = getIndex(nextVersionDocuments[0])
        } else {
          result.push(documents.shift())
          cDIndex = getIndex(documents[0])
        }
      }
    }

    const result = documentsByVersion[schemaVersion]

    if (singleDocument) {
      return result[0]
    }

    return result
  }

  return updateDocuments
}

export default createSchema